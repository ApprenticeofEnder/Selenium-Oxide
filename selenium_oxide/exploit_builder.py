from typing import Optional
from selenium import webdriver
from selenium.webdriver.firefox.firefox_binary import FirefoxBinary
from selenium.webdriver.common.proxy import Proxy, ProxyType
from selenium.webdriver.common.keys import Keys
import time
import random

class ExploitBuilder:
    def __init__(
        self, 
        protocol: str, 
        hostname: str, 
        stealth: Optional[bool] = False, 
        firefox_binary_path: Optional[str] = "/opt/firefox/firefox",
        useProxy: Optional[bool] = False,
        proxyAddress: Optional[str] = "127.0.0.1:8080",
    ):
        self.protocol = protocol
        self.hostname = hostname
        binary = FirefoxBinary(firefox_binary_path)
        if useProxy and proxyAddress:
            proxy = Proxy({
                "proxyType": ProxyType.MANUAL,
                "httpProxy": proxyAddress,
                "sslProxy": proxyAddress,
                "noProxy": ''
            })
            proxy.add_to_capabilities(webdriver.DesiredCapabilities.FIREFOX)
            fp = webdriver.FirefoxProfile()
            fp.set_preference("network.proxy.type", 1)
            fp.set_preference("network.proxy.http", proxyAddress.split(":")[0])
            fp.set_preference("network.proxy.http_port", int(proxyAddress.split(":")[1]))
            fp.set_preference('network.proxy.allow_hijacking_localhost', True)
            fp.update_preferences()
            self.driver = webdriver.Firefox(
                firefox_binary=binary,
                proxy=proxy,
                firefox_profile=fp
            )
        else:
            self.driver = webdriver.Firefox(firefox_binary=binary)
        self.stealth = stealth

    def get(self, endpoint: str):
        self.driver.get(self._format(endpoint))
        return self

    def login(self, endpoint: str, username: str, password: str, username_id: str, password_id: str, submit_id: str):
        (
            self.get(endpoint)
                .type_by_id(username_id, username)
                .type_by_id(password_id, password)
                .click_by_id(submit_id)
        )
        return self

    def type_by_id(self, field: str, entry: str):
        self.wait_for_stealth(entry)
        element = self.driver.find_element_by_id(field)
        element.send_keys(entry)
        return self

    def type_by_class(self, field: str, entry: str):
        self.wait_for_stealth(entry)
        element = self.driver.find_element_by_class_name(field)
        element.send_keys(entry)
        return self

    def get_contents(self, field: str):
        return self.driver.find_element_by_id(field).text

    def send_enter_by_id(self, field: str):
        self.driver.find_element_by_id(field).send_keys(Keys.ENTER)
        return self

    def send_enter_by_class(self, field: str):
        self.driver.find_element_by_class_name(field).send_keys(Keys.ENTER)
        return self

    def click_by_id(self, button_id: str):
        self.driver.find_element_by_id(button_id).click()
        return self

    def click_by_class(self, button_class: str):
        self.driver.find_element_by_class_name(button_class).click()
        return self

    def _format(self, endpoint: str) -> str:
        return f"{self.protocol}://{self.hostname}{endpoint}"

    def dump_cookies(self):
        for cookie in self.get_cookies():
            print(cookie)
        return self

    def get_cookies(self):
        return self.driver.get_cookies()

    def get_cookie_by_name(self, name: str) -> Optional[dict]:
        for cookie in self.get_cookies():
            if cookie["name"] == name:
                return cookie
        return None

    def set_cookie(self, name, value, path="/", secure=False):
        self.driver.add_cookie({
            "name": name,
            "value": value,
            "path": path,
            "secure": secure
        })
        return self

    def wait_for_stealth(self, entry=""):
        if self.stealth:
            time.sleep(len(entry) / 5 + random.uniform(0.2, 1))
